epic_id: state-machine
title: Python State Machine Enforcement for Epic Execution
description: |
  Replace LLM-driven coordination with a Python state machine that enforces
  structured execution of epic tickets. The state machine acts as a programmatic
  gatekeeper, enforcing precise git strategies (stacked branches with final
  collapse), state transitions, and merge correctness while the LLM focuses solely
  on implementing ticket requirements.

  Git Strategy Summary:
  - Tickets execute synchronously (one at a time)
  - Each ticket branches from previous ticket's final commit (true stacking)
  - Epic branch stays at baseline during execution
  - After all tickets complete, collapse all branches into epic branch (squash merge)
  - Push epic branch to remote for human review

  Problem Statement:
  The current execute-epic approach leaves too much coordination logic to the LLM
  orchestrator, leading to inconsistent execution quality, no enforcement of
  invariants, state drift, non-deterministic behavior, and debugging difficulties.

  Core Insight: LLMs are excellent at creative problem-solving (implementing
  features, fixing bugs) but poor at following strict procedural rules
  consistently. Invert the architecture: State machine handles procedures, LLM
  handles problems.

goals:
  - Deterministic State Transitions - Python code enforces state machine rules, LLM cannot bypass gates
  - Git Strategy Enforcement - Stacked branch creation, base commit calculation, and merge order handled by code
  - Validation Gates - Automated checks before allowing state transitions (branch exists, tests pass, etc.)
  - LLM Interface Boundary - Clear contract between state machine (coordinator) and LLM (worker)
  - Auditable Execution - State machine logs all transitions and gate checks for debugging
  - Resumability - State machine can resume from epic-state.json after crashes

success_criteria:
  - State machine written in Python with explicit state classes and transition rules
  - LLM agents interact with state machine via CLI commands only (no direct state file manipulation)
  - Git operations (branch creation, base commit calculation, merging) are deterministic and tested
  - Validation gates automatically verify LLM work before accepting state transitions
  - Epic execution produces identical git structure on every run (given same tickets)
  - State machine can resume mid-epic execution from state file
  - Integration tests verify state machine enforces all invariants

technical_approach: |
  Core Principle: State Machine as Gatekeeper

  The architecture inverts control - the state machine owns all procedural logic
  (git operations, state transitions, validation) while the LLM focuses solely on
  implementing ticket requirements.

  Component Architecture:
  - EpicStateMachine: Owns epic-state.json, enforces all state transitions, performs
    git operations, validates LLM output against gates
  - LLM Orchestrator Agent: Reads ticket requirements, spawns ticket-builder sub-agents,
    calls state machine to advance states, NO direct state file access
  - Ticket-Builder Sub-Agents: Implement ticket requirements, create commits on assigned
    branch, report completion with artifacts, NO state machine interaction

  Git Strategy: True Stacked Branches with Final Collapse

  Key Properties:
  1. Epic branch stays at baseline during ticket execution (no progressive merging)
  2. Tickets stack on each other - each ticket branches from previous ticket's final commit
  3. Synchronous execution - one ticket at a time (concurrency = 1)
  4. Deferred merging - all merges happen after all tickets are complete
  5. Squash strategy - each ticket becomes single commit on epic branch
  6. Cleanup - ticket branches deleted after merge

  Execution Flow:
  Phase 1: Build tickets (stacked branches)
    - ticket/A branches from epic baseline → work → complete
    - ticket/B branches from ticket/A final commit → work → complete
    - ticket/C branches from ticket/B final commit → work → complete

  Phase 2: Collapse into epic branch
    - epic/feature ← squash merge ticket/A
    - epic/feature ← squash merge ticket/B
    - epic/feature ← squash merge ticket/C
    - delete ticket/A, ticket/B, ticket/C
    - push epic/feature

  Phase 3: Human review
    - epic/feature pushed to remote
    - Human creates PR (epic/feature → main)

  State Machine Design:

  Ticket States: PENDING → READY → BRANCH_CREATED → IN_PROGRESS →
                 AWAITING_VALIDATION → COMPLETED (or FAILED/BLOCKED)

  Epic States: INITIALIZING → EXECUTING → MERGING → FINALIZED
               (with FAILED → ROLLED_BACK path)

  Transition Gates:
  - DependenciesMetGate (PENDING → READY): Verify all dependencies are COMPLETED
  - CreateBranchGate (READY → BRANCH_CREATED): Create git branch from correct base commit
  - LLMStartGate (BRANCH_CREATED → IN_PROGRESS): Verify LLM can start (synchronous enforcement)
  - ValidationGate (AWAITING_VALIDATION → COMPLETED): Comprehensive validation of LLM work

  LLM Orchestrator Interface:
  LLM interacts with state machine via CLI commands only:
  - buildspec epic status <epic-file> --ready: Get ready tickets
  - buildspec epic start-ticket <epic-file> <ticket-id>: Start ticket (creates branch)
  - buildspec epic complete-ticket <epic-file> <ticket-id>: Complete ticket (validates)
  - buildspec epic fail-ticket <epic-file> <ticket-id>: Mark ticket as failed
  - buildspec epic finalize <epic-file>: Collapse all tickets into epic branch and push

  Implementation Strategy:
  Phase 1: Core state machine (state enums, gates, state machine core, git operations)
  Phase 2: CLI commands (Click commands for epic operations)
  Phase 3: LLM integration (Update execute-epic.md with orchestrator instructions)
  Phase 4: Validation gates (Implement all transition gates)
  Phase 5: Error recovery (Rollback, resume, dependency blocking)
  Phase 6: Integration tests (Happy path, failures, dependencies, crash recovery)

architecture_overview: |
  Core Architecture Diagram:

  ┌─────────────────────────────────────────────────────────┐
  │  execute-epic CLI Command (Python)                      │
  │  ┌───────────────────────────────────────────────────┐  │
  │  │  EpicStateMachine                                 │  │
  │  │  - Owns epic-state.json                           │  │
  │  │  - Enforces all state transitions                 │  │
  │  │  - Performs git operations                        │  │
  │  │  - Validates LLM output against gates             │  │
  │  └───────────────────────────────────────────────────┘  │
  │                        ▲                                │
  │                        │ API calls only                 │
  │                        ▼                                │
  │  ┌───────────────────────────────────────────────────┐  │
  │  │  LLM Orchestrator Agent                           │  │
  │  │  - Reads ticket requirements                      │  │
  │  │  - Spawns ticket-builder sub-agents               │  │
  │  │  - Calls state machine to advance states          │  │
  │  │  - NO direct state file access                    │  │
  │  └───────────────────────────────────────────────────┘  │
  │                        │                                │
  │                        │ Task tool spawns               │
  │                        ▼                                │
  │  ┌───────────────────────────────────────────────────┐  │
  │  │  Ticket-Builder Sub-Agents (LLMs)                 │  │
  │  │  - Implement ticket requirements                  │  │
  │  │  - Create commits on assigned branch              │  │
  │  │  - Report completion with artifacts               │  │
  │  │  - NO state machine interaction                   │  │
  │  └───────────────────────────────────────────────────┘  │
  └─────────────────────────────────────────────────────────┘

  Git Strategy Timeline:

  main ──────────────────────────────────────────────────────────►
    │
    └─► epic/feature (created from main, stays at baseline)
          │
          └─► ticket/A ──► (final commit: aaa111)
                 │
                 └─► ticket/B ──► (final commit: bbb222)
                        │
                        └─► ticket/C ──► (final commit: ccc333)

  [All tickets validated and complete]

  epic/feature ──► [squash merge A] ──► [squash merge B] ──► [squash merge C] ──► push
                   (clean up ticket/A)  (clean up ticket/B)  (clean up ticket/C)

  State Machine Core Classes:

  - TicketState(Enum): PENDING, READY, BRANCH_CREATED, IN_PROGRESS,
                       AWAITING_VALIDATION, COMPLETED, FAILED, BLOCKED

  - EpicState(Enum): INITIALIZING, EXECUTING, MERGING, FINALIZED,
                     FAILED, ROLLED_BACK

  - TransitionGate(Protocol): Interface for validation gates that check if
                               state transition is allowed

  - EpicStateMachine: Core state machine with public API for LLM orchestrator
    - get_ready_tickets(): Returns tickets ready to execute
    - start_ticket(ticket_id): Creates branch and transitions to IN_PROGRESS
    - complete_ticket(ticket_id, ...): Validates work and transitions to COMPLETED
    - fail_ticket(ticket_id, reason): Marks ticket failed and blocks dependents
    - finalize_epic(): Collapses all tickets into epic branch and pushes
    - get_epic_status(): Returns current execution status

  Key Design Decisions:

  1. State Machine Owns Git Operations: Ensures deterministic branch naming and
     base commit calculation

  2. Validation Gates Run After LLM Reports Completion: LLM claims completion,
     then state machine validates

  3. State File is Private to State Machine: LLM never reads or writes
     epic-state.json directly

  4. Deferred Merging (Final Collapse Phase): Tickets marked COMPLETED after
     validation, merging happens in separate finalize phase

  5. Synchronous Execution (Concurrency = 1): State machine enforces synchronous
     execution (one ticket at a time)

  6. Base Commit Calculation is Deterministic: Explicit algorithm for stacked
     base commits (dependency's final commit)
